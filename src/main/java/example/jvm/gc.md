# GC要解决的三个问题

1. 那些对象需要回收？
2. 何时回收？
3. 如何回收？

## 1 那些对象需要回收？

目前有两种方式判断对象是否需要回收：

### 1.1 引用计数法
记录对象被引用的次数。但是无法解决循环引用的问题。

### 1.2 可达性分析

根据GC Root 对象递归检查，检查到的对象都不用回收。否则就是垃圾对象。GC Root对象来自于：
1. java线程栈中的栈帧中的局部变量表中的引用。
2. 元数据区中的引用：静态变量。

## 2 垃圾收集算法

### 2.1 标记-清理

根据可达性分析找到垃圾对象，就地清理对象。

缺点：造成内存碎片。

### 2.2 标记-复制

把内存等分为两块A和B，把非垃圾对象整体复制到B，然后整体回收A，如此往复。

缺点：内存浪费严重。

不过经过java团队的研究发现，98%的对象都是朝生夕死的，所以把内存划分成了8:1:1。其中8是新生代，优先分配到次。
1:1的是两个交换区AB，一次只使用其中的一个。这样可以兼顾空间和性能。

### 2.3 标记-整理

根据可达性分析找到垃圾对象，按照整理移动的方式避免标记-清理造成的内存碎片。用在老年代上。

### 2.4 分代回收

分为新、老代，分别选择合适的算法。
新生代使用复制，老年代使用整理。

G1不再明确区分老年代和新生代，而是把内存化分成很多等分的区块，G1动态的调整它的用途。
通过追踪这些区块的信息，然后根据设定的垃圾回收时间，动态的选择回收其中的一部分，而不是之前的那种全部回收。

## 3 何时回收？

到达安全点。


## 4 垃圾收集器

STW: Stop The World.

1. Serial: 新生代。标记-复制。单线程。
2. Serial Old ：老年代。标记-整理。单线程。
3. ParNew/: 新生代。标记-复制。多线程版的Serial。
4. Parallel Scavenge: 新生代。标记-复制。多线程。关注于吞吐量，即用户代码的运行时间/用户代码的运行时间+GC的时间。
5. Parallel Old：老年代。标记-整理。Parallel Scavenge的老年代版本。
6. CMS : 老年代。标记-清理。关注于最短回收停顿时间。
    1. 初始标记（CMS initial mark）: STW。仅记录GC root直接关联的对象。
    2. 并发标记（CMS concurrent mark）: 耗时最慢的缓解不SWT。在1的基础上遍历整个对象图，和用户代码并行运行。
    3. 重新标记（CMS remark）: SWT。修正并发标记阶段产生变动的一部分对象。
    4. 并发清除（CMS concurrent sweep）。仅清理，并不需要移动对象，也和用户代码并行。
7. G1(Garbage First): 新老年代。混合GC。基于把内存分为Region小块，局部收集（
追踪每个Region的垃圾的回收价值大小，然后依据能回收的空间和所消耗的时间比，选择性的优先回收某一部分Region）。
每一个区块都可以是新生代、交换区或者老年代。动态调整。还有一个Humongous区域，大对象专属。
    1. 初始标记（Initial Marking）: STW。仅记录GC root直接关联的对象。并且修改TAMS指针的值，让下阶段用户线程运行时，能正确的在可用的Region中分配对象。
    2. 并发标记（Concurrent Marking）: 耗时最慢的缓解不SWT。和用户代码并行运行。在1的基础上遍历整个对象图，然后重新处理SATB记录下的在并发时有引用变动的对象。
    3. 最总标记（Final Marking）: SWT。处理2遗留的少量SATB记录。
    4. 筛选回收（Live Data Counting And Evacuation）。更新Region的统计数据，对回收价值和成本排序，根据设置的期望停顿时间制定回收计划。
    然后选择任意个Region中的存活对象复制到空的Region中，再清理掉旧的Region的全部空间（SWT）。




