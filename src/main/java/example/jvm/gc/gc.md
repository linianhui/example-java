# GC要解决的三个问题

1. 那些对象需要回收？
2. 何时回收？
3. 如何回收？

## 1 那些对象需要回收？

目前有两种方式判断对象是否需要回收：

### 1.1 引用计数法
记录对象被引用的次数。但是无法解决循环引用的问题。

### 1.2 可达性分析

根据GC Root 对象递归检查，检查到的对象都不用回收。否则就是垃圾对象。GC Root对象来自于：
1. java线程栈中的栈帧中的局部变量表中的引用。
2. 元数据区中的引用：静态变量。

## 2 垃圾收集算法

### 2.1 标记-清理

根据可达性分析找到垃圾对象，就地清理对象。

缺点：造成内存碎片。

### 2.2 标记-复制

把内存等分为两块A和B，把非垃圾对象整体复制到B，然后整体回收A，如此往复。

缺点：内存浪费严重。

不过经过java团队的研究发现，98%的对象都是朝生夕死的，所以把内存划分成了8:1:1。其中8是新生代，优先分配到次。
1:1的是两个交换区AB，一次只使用其中的一个。这样可以兼顾空间和性能。

### 2.3 标记-整理

根据可达性分析找到垃圾对象，按照整理移动的方式避免标记-清理造成的内存碎片。用在老年代上。

### 2.4 分代回收

分为新、老代，分别选择合适的算法。
新生代使用复制，老年代使用整理。

G1不再明确区分老年代和新生代，而是把内存化分成很多等分的区块，G1动态的调整它的用途。
通过追踪这些区块的信息，然后根据设定的垃圾回收时间，动态的选择回收其中的一部分，而不是之前的那种全部回收。

## 3 何时回收？








